<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="leaflet/leaflet.css"
          crossorigin=""/>
    <script src="leaflet/leaflet.js"
            crossorigin=""></script>

    <style>
        html, body {
            height: 100%;
            margin: 0;
        }
        #mapdeck7 {
            width: 1922px;
            height: 1048px;
        }

    </style>
    <title>BFT Web Map - Leaflet</title>
</head>
<body>
<h1>Ship decks</h1>

<h2>Deck 7</h2>
<div id="mapdeck7"></div>
<h2>Deck 6 (Captain's Deck)</h2>
<div id="mapdeck6"></div>
<h2>Deck 5</h2>
<div id="mapdeck5"></div>
<h2>Deck 4</h2>
<div id="mapdeck4"></div>
<h2>Deck 3</h2>
<div id="mapdeck3"></div>
<h2>Deck 2 (Poop Deck)</h2>
<div id="mapdeck2"></div>
<h2>Tween Deck </h2>
<div id="mapdecktween"></div>
<h2>2nd Deck</h2>
<div id="mapdeck2nd"></div>
<h2>3rd Deck</h2>
<div id="mapdeck3rd"></div>
<h2>Platform Deck</h2>
<div id="mapdeckplatform"></div>
<h2>Double Bottom</h2>
<div id="mapdeckdoublebottom"></div>

<script>
    var factor = 1922/55;
    // var factorx = 36.945
    // var factory = 36.945
    //
    // L.CRS.pr = L.extend({}, L.CRS.Simple, {
    //     projection: L.Projection.LonLat,
    //     transformation: new L.Transformation(factorx, 0, -factory, 0),
    //     // Changing the transformation is the key part, everything else is the same.
    //     // By specifying a factor, you specify what distance in meters one pixel occupies (as it still is CRS.Simple in all other regards).
    //     // In this case, I have a tile layer with 256px pieces, so Leaflet thinks it's only 256 meters wide.
    //     // I know the map is supposed to be 2048x2048 meters, so I specify a factor of 0.125 to multiply in both directions.
    //     // In the actual project, I compute all that from the gdal2tiles tilemapresources.xml,
    //     // which gives the necessary information about tilesizes, total bounds and units-per-pixel at different levels.
    //
    //
    //     // Scale, zoom and distance are entirely unchanged from CRS.Simple
    //     scale: function(zoom) {
    //         return Math.pow(2, zoom);
    //     },
    //
    //     zoom: function(scale) {
    //         return Math.log(scale) / Math.LN2;
    //     },
    //
    //     distance: function(latlng1, latlng2) {
    //         var dx = latlng2.lng - latlng1.lng,
    //             dy = latlng2.lat - latlng1.lat;
    //
    //         return Math.sqrt(dx * dx + dy * dy);
    //     },
    //     infinite: true
    // });

    var map0 = L.map('Lateral View', {
        crs: L.CRS.Simple,
        minZoom: -5
    });

    var bounds0 = [[(-16.110822*factor),(-5*factor)], [(13.7356919*factor),(50*factor)]];
    console.debug(bounds0)
    var image0 = L.imageOverlay('LATERALDECK.png', bounds0).addTo(map0);

    var sol = L.latLng([ 0*factor, 0*factor ]);
    L.marker(sol).addTo(map0);

    var sol = L.latLng([ 0*factor, 5*factor ]);
    L.marker(sol).addTo(map0);

    var sol = L.latLng([ 0*factor, 10*factor ]);
    L.marker(sol).addTo(map0);

    map0.setView( [0, 0], 1);

    map0.fitBounds(bounds0);



</script>
</body>
</html>